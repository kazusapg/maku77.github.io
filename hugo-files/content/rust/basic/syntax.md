---
title: "10 分で理解する Rust 文法"
url: "p/63m4k3i/"
date: "2022-12-13"
tags: ["Rust"]
draft: true
---

Rust 言語の文法をざっと理解するためのページです。
以下をざっと読めば、8 割くらいの Rust コードは読めるようになります。

変数
----

- デフォルトで変更不可の変数 (immutable variable) になる
  ```rust
  let n = 100;
  n = 200;  // Error!
  ```
- 可変の変数にしたいときは __`let mut`__ を使う
  ```rust
  let mut n = 100;
  n = 200;  // OK
  ```
- 変数の再宣言 (redeclaration) により変数名を使いまわせる
  ```rust
  let s = "  ABC  ";
  let s = s.trim();
  ```

関数
----

関数はどこかで定義されていればよく、呼び出し前に定義しておく必要はありません。
次の `plus_one` 関数は、`i32` 型の整数値を 1 つ受け取り、戻り値として `i32` 型の整数値を返します。

```rust
fn main() {
    println!("{}", plus_one(100)); //=> 101
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

Rust では、`{}` で囲まれたブロックの最後をセミコロンで終了しないと、その計算結果がブロック全体の値として評価されます（式として扱われます）。
上記の例では、関数ブロックの末尾の `x + 1` にセミコロンが付いていないので、その値が関数の戻り値として扱われます。
明示的に `return` キーワードを使用する場合は、セミコロンを付けることができます。

```rust
fn plus_one(x: i32) -> i32 {
    return x + 1;
}
```


Vec 型（可変サイズのベクター型）
----

Rust のベクター型 (`Vec`) は、C++ の `std::vector` 型に相当するもので、可変サイズの配列として使用できます。
ベクターを生成するには、__`vec!`__ マクロを使用します。

```rust
let mut v = vec!["AAA", "BBB"]; // Vec<&str> 型
v.push("CCC");
v.push("DDD");
v[0] = "XXX";
println!("{:?}", v); //=> ["XXX", "BBB", "CCC", "DDD"]
```

ベクターは配列と同様に、初期化時にサイズを指定できますが、このサイズ指定に変数を使用できます（配列では許されていません）。

```rust
let length = 3;
let v = vec!["AAA"; length];
println!("{:?}", v); //=> ["AAA", "AAA", "AAA"]
```

下記は、よく使うベクター操作です。

```rust
v.push("AAA");       // 末尾に要素を追加
a = v.pop();         // 末尾の要素を取り出して削除
v.insert(0, "XXX");  // 指定したインデックスの前に要素を追加
v.remove(0);         // 指定したインデックスの要素を削除
```


数値リテラル
----

{{< code lang="rust" title="プレフィックス" >}}
0x10  // 16進数 (= 16)
0o10  // 8進数 (= 8)
0b10  // 2進数 (= 2)
{{< /code >}}

{{< code lang="rust" title="可読性のためのアンダースコア" >}}
1_234_567    // アンダースコアを自由に入れて OK
0b1100_0101  // 2進数リテラルでもアンダースコアを使える
{{< /code >}}

{{< code lang="rust" title="浮動小数点数の指数表記" >}}
12.3e6   // 12.3 * 10^6 (= 12300000)
12.3e-6  // 12.3 * 10^-6 (= 0.0000123)
{{< /code >}}


型注釈 (type annotation)
----

```rust
let a: u8 = 200;
```

数値リテラルから変数を生成するときに、型注釈をつけることで具体的なサイズや符号の有無を制御できます。
型を省略した場合（かつコンパイラが型推論できない場合）は、デフォルトで `i32` 型が使用されます（浮動小数点数の場合は `f64`）。

- 整数の型（符号あり）: `i8`, `i16`, `i32`, `i64`, `i128`（デフォルトは `i32`）
- 整数の型（符号なし）: `u8`, `u16`, `u32`, `u64`, `u128`
- 浮動小数点数の型: `f32`, `f64`（デフォルトは `f64`）
- 特殊な型: `usize`（配列のインデックスやサイズ用で、実質 unsigned int）

{{< code lang="rust" title="usize の使用例" >}}
const N: usize = 5;
let arr = [0; N];  //=> [0, 0, 0, 0, 0]（型は [i32; 5]）
{{< /code >}}


スライス
----

スライスは、配列などのコレクション要素を部分的に参照（借用）するための構文です。
取得した参照は、不変参照になります。
例えば、次の例では `i32` 配列のスライスを取得しており、その型は __`&[i32]`__ です。

```rust
let arr = [0, 1, 2, 3, 4];

let a1 = &arr[1..4];  //=> [1, 2, 3] （&[i32] 型）
let a2 = &arr[..3];   //=> [0, 1, 2] （&[i32] 型）
let a3 = &arr[2..];   //=> [2, 3, 4] （&[i32] 型）
```

文字列のスライスを作成することもできます。
文字列スライスも不変参照であり、__`&str`__ 型として扱われます。
`&str` は文字列の一部を参照するための不変 (immutable) な型として用意されており、その可変バージョン (`&mut str`) は存在しません。

```rust
let s = "ABCDE";  // 実はこれも `&str` 型

let s1 = &s[1..4];  //=> "BCD" （&str 型）
let s2 = &s[..3];   //=> "ABC" （&str 型）
let s3 = &s[2..];   //=> "CDE" （&str 型）
```

文字列スライス（文字列の不変参照）の型 `&str` は、関数のパラメーターとして文字列を受け取るときによく使われます。
`&str` 型で文字列を受け取るようにしておけば、文字列リテラル (`&str`) と `String` オブジェクト（から生成した参照）のどちらでも受け取れるようになります。

```rust
// 文字列は &str 型で受け取るとよい
fn first_two_chars(s: &str) -> &str {
    &s[..2]
}

fn main() {
    println!("{}", first_two_chars("ABC"));  // 文字列リテラルはそのまま渡せる

    let s1 = "ABC";  // &str 型
    println!("{}", first_two_chars(s1));  // &str なのでそのまま渡せる

    let s2 = String::from("ABCDE");  // String 型
    println!("{}", first_two_chars(&s2[..]));  // 文字列スライス (&str) にして渡す
    println!("{}", first_two_chars(&s2));  // &String も &str として解釈してくれる
}
```


列挙型 (enum) と match
----

Rust の列挙型 (enum) は、各列挙子 (variant) に任意の値を保持することができるので非常に強力です。
列挙型にはメソッドを追加することさえできます。

### enum の基本

```rust
// enum 型の定義
enum Fruit {
    Apple,
    Banana,
    Orange,
}

// enum 型の使用例
let fruit = Fruit::Banana;
match fruit {
    Fruit::Apple => println!("I like apples"),
    Fruit::Banana => println!("I like bananas"),
    Fruit::Orange => println!("I like oranges"),
}
```

### enum 型に値を持たせる


その他
----

- 標準ライブラリ（`str` など）はインクルードなしでデフォルトで使える

