---
title: "Bash の構文 ─ for/while によるループ処理"
date: "2008-10-28"
---

コマンドライン引数をループ処理する
----

### for ループによる処理

コマンドラインからシェルスクリプトを実行するときに渡されたパラメータを順番に処理するには下記のように `for` ループを記述します。
ここでは、`do` を `for` と同じ行に記述するコーディングスタイルを採用しています。

#### sample.sh

~~~ bash
#!/bin/bash

for x; do
  echo "Parameter: $x"
done
~~~

#### 実行結果

~~~
$ ./sample.sh 100 200 300
Parameter: 100
Parameter: 200
Parameter: 300
~~~

これは、実は、下記のように `$*`（コマンドラインパラメータ）をループ処理するときの省略記法です。

~~~ bash
for x in $*; do
  echo "Parameter: $x"
done
~~~


### while ループによる処理

`for` ループは与えられた要素を順番に最後まで処理するものですが、`while` ループは指定した条件を満たす限り処理を繰り返したいときに使用します。
例えば、下記のようにコマンドラインパラメータを `while` ループで順番に処理することができます（ただし、`for` ループを使ったほうがシンプルです）。

``` bash
while [ $# -gt 0 ]; do
  echo $1
  shift
done
```

`$#` はコマンドラインパラメータの数を示しており、パラメータの数が 0 より大きいという条件を満たす限りループ処理を続けています（`test` コマンド (`[`) の `-gt` (greater than) で大小比較）。
`$1` はコマンドラインパラメータの最初の要素を参照する変数ですが、直後の `shift` によってパラメータを 1 つずつシフトしているので、結果としてすべてのパラメータを順番に参照することができます。


スペースで区切られた単語（ワード）を順番に処理する
----

次の例では、ループ処理したいテキスト (`aaa`, `bbb`, `ccc`) を直接 `for` ループで指定しています。

#### 例: aaa bbb ccc を順番に処理

~~~ bash
for x in aaa bbb ccc; do
  echo $x
done
~~~

#### 実行結果

~~~
aaa
bbb
ccc
~~~

以下のように、スペースで区切られた文字列が格納された文字列変数を処理することもできます。

~~~ bash
list="aaa bbb ccc"
for x in $list; do
  echo $x
done
~~~


スペースを含む文字列を1つの要素として扱う
----

リスト内の各要素をダブルクォートで囲んでおくと、その単位でループ処理されるようになります。

~~~ bash
#!/bin/bash

for i in "aaa bbb" "ccc ddd" "eee fff"; do
  echo $i
done
~~~

#### 実行結果

~~~
aaa bbb
ccc ddd
eee fff
~~~

変数を使う場合もほぼ同様ですが、**それぞれの変数をダブルクォートで囲う**必要があります（これを忘れると、それぞれの変数内の文字列がスペースで区切られてループ処理されてしまいます）。

~~~ bash
x="aaa bbb"
y="ccc ddd"
z="eee fff"

for i in "$x" "$y" "$z"; do
  echo $i
done
~~~

#### 実行結果

~~~
aaa bbb
ccc ddd
eee fff
~~~

ちなみに、下記のようにすべての変数をまとめてダブルクォートで囲むと、ひとつの要素として処理されます。

~~~ bash
for i in "$x $y $z"; do
  echo $i
done
~~~

#### 実行結果

~~~
aaa bbb ccc ddd eee fff
~~~


任意のコマンドの実行結果を一行ずつ処理する
----

例えば、`ls -aFl` といった外部コマンドの出力結果を一行ずつ処理するには、下記のようにパイプで `while read` に繋ぎます。
`line` というのは変数名なので別の名前に変えても大丈夫です。

~~~ bash
ls -aFl | while read line; do
  echo "$line"
done
~~~

<div class="note">
<code>$line</code> をダブルクォーテーションで囲んでいるのは、<code>echo</code> が行中の連続したスペースを 1 つのスペースにまとめて出力してしまうのを防ぐためです。
</div>

### おまけ: IFS 変数を使った方法

`while read` を使う方法ではなく、`IFS` 変数の値を変更することで、コマンドの出力結果を 1 行ずつ処理する方法もあります。

~~~ bash
IFS='
'

for i in $( ls -aFl ); do
  echo $i
done

unset IFS
~~~

`for` ループの `in` の後ろに渡した文字列は、デフォルトでは各要素がスペースで区切られているとみなされます。
`IFS` 変数の値を上記のように改行だけ含むように変更すると、`for` ループの各要素が改行で区切られるようになります。
`IFS` 変数を `unset` すると、元に戻ってスペースで区切られるようになります。


応用: 複数の要素の組み合わせ
----

次のように `for` ループに渡す処理を `{` と `}` を使ってグルーピングすると、それぞれのグループ内の要素の組み合わせでループすることができます。

~~~ bash
for x in {A,B,C}-{1,2}; do
  echo $x
done
~~~

#### 実行結果

~~~
A-1
A-2
B-1
B-2
C-1
C-2
~~~


応用: C/C++ のような for ループを記述する
----

次のように括弧を重ねて使用することで、C/C++ のようなフォーマットで for ループを記述することができます。
気持ち悪いのでオススメはしませんが。。。

~~~ bash
for (( i=0 ; i<3 ; ++i )); do
  echo $i
done
~~~

#### 実行結果

~~~
0
1
2
~~~

ちなみに、上記のような連番を生成したい場合は、`seq` コマンドを使うと柔軟に生成することができます。

~~~ bash
for i in `seq 0 2`; do
  echo $i
done
~~~

#### 実行結果

~~~
0
1
2
~~~

`seq` コマンドでは、1ループごとのステップをマイナスにしたり、小数点数にしたりできます。

~~~ bash
for i in `seq 1 -0.1 0.5`; do
  echo $i
done
~~~

#### 実行結果

~~~
1.0
0.9
0.8
0.7
0.6
0.5
~~~

